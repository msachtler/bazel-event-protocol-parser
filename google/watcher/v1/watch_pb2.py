# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/watcher/v1/watch.proto

import sys
_b=sys.version_info[0]<3 and (lambda x:x) or (lambda x:x.encode('latin1'))
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database
from google.protobuf import descriptor_pb2
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


from google.api import annotations_pb2 as google_dot_api_dot_annotations__pb2
from google.protobuf import any_pb2 as google_dot_protobuf_dot_any__pb2
from google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2


DESCRIPTOR = _descriptor.FileDescriptor(
  name='google/watcher/v1/watch.proto',
  package='google.watcher.v1',
  syntax='proto3',
  serialized_pb=_b('\n\x1dgoogle/watcher/v1/watch.proto\x12\x11google.watcher.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x19google/protobuf/any.proto\x1a\x1bgoogle/protobuf/empty.proto\"0\n\x07Request\x12\x0e\n\x06target\x18\x01 \x01(\t\x12\x15\n\rresume_marker\x18\x02 \x01(\x0c\"9\n\x0b\x43hangeBatch\x12*\n\x07\x63hanges\x18\x01 \x03(\x0b\x32\x19.google.watcher.v1.Change\"\xe6\x01\n\x06\x43hange\x12\x0f\n\x07\x65lement\x18\x01 \x01(\t\x12.\n\x05state\x18\x02 \x01(\x0e\x32\x1f.google.watcher.v1.Change.State\x12\"\n\x04\x64\x61ta\x18\x06 \x01(\x0b\x32\x14.google.protobuf.Any\x12\x15\n\rresume_marker\x18\x04 \x01(\x0c\x12\x11\n\tcontinued\x18\x05 \x01(\x08\"M\n\x05State\x12\n\n\x06\x45XISTS\x10\x00\x12\x12\n\x0e\x44OES_NOT_EXIST\x10\x01\x12\x19\n\x15INITIAL_STATE_SKIPPED\x10\x02\x12\t\n\x05\x45RROR\x10\x03\x32\x63\n\x07Watcher\x12X\n\x05Watch\x12\x1a.google.watcher.v1.Request\x1a\x1e.google.watcher.v1.ChangeBatch\"\x11\x82\xd3\xe4\x93\x02\x0b\x12\t/v1/watch0\x01\x42_\n\x15\x63om.google.watcher.v1B\nWatchProtoP\x01Z8google.golang.org/genproto/googleapis/watcher/v1;watcherb\x06proto3')
  ,
  dependencies=[google_dot_api_dot_annotations__pb2.DESCRIPTOR,google_dot_protobuf_dot_any__pb2.DESCRIPTOR,google_dot_protobuf_dot_empty__pb2.DESCRIPTOR,])



_CHANGE_STATE = _descriptor.EnumDescriptor(
  name='State',
  full_name='google.watcher.v1.Change.State',
  filename=None,
  file=DESCRIPTOR,
  values=[
    _descriptor.EnumValueDescriptor(
      name='EXISTS', index=0, number=0,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='DOES_NOT_EXIST', index=1, number=1,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='INITIAL_STATE_SKIPPED', index=2, number=2,
      options=None,
      type=None),
    _descriptor.EnumValueDescriptor(
      name='ERROR', index=3, number=3,
      options=None,
      type=None),
  ],
  containing_type=None,
  options=None,
  serialized_start=401,
  serialized_end=478,
)
_sym_db.RegisterEnumDescriptor(_CHANGE_STATE)


_REQUEST = _descriptor.Descriptor(
  name='Request',
  full_name='google.watcher.v1.Request',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='target', full_name='google.watcher.v1.Request.target', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=_b("").decode('utf-8'),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='resume_marker', full_name='google.watcher.v1.Request.resume_marker', index=1,
      number=2, type=12, cpp_type=9, label=1,
      has_default_value=False, default_value=_b(""),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=138,
  serialized_end=186,
)


_CHANGEBATCH = _descriptor.Descriptor(
  name='ChangeBatch',
  full_name='google.watcher.v1.ChangeBatch',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='changes', full_name='google.watcher.v1.ChangeBatch.changes', index=0,
      number=1, type=11, cpp_type=10, label=3,
      has_default_value=False, default_value=[],
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
  ],
  options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=188,
  serialized_end=245,
)


_CHANGE = _descriptor.Descriptor(
  name='Change',
  full_name='google.watcher.v1.Change',
  filename=None,
  file=DESCRIPTOR,
  containing_type=None,
  fields=[
    _descriptor.FieldDescriptor(
      name='element', full_name='google.watcher.v1.Change.element', index=0,
      number=1, type=9, cpp_type=9, label=1,
      has_default_value=False, default_value=_b("").decode('utf-8'),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='state', full_name='google.watcher.v1.Change.state', index=1,
      number=2, type=14, cpp_type=8, label=1,
      has_default_value=False, default_value=0,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='data', full_name='google.watcher.v1.Change.data', index=2,
      number=6, type=11, cpp_type=10, label=1,
      has_default_value=False, default_value=None,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='resume_marker', full_name='google.watcher.v1.Change.resume_marker', index=3,
      number=4, type=12, cpp_type=9, label=1,
      has_default_value=False, default_value=_b(""),
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
    _descriptor.FieldDescriptor(
      name='continued', full_name='google.watcher.v1.Change.continued', index=4,
      number=5, type=8, cpp_type=7, label=1,
      has_default_value=False, default_value=False,
      message_type=None, enum_type=None, containing_type=None,
      is_extension=False, extension_scope=None,
      options=None),
  ],
  extensions=[
  ],
  nested_types=[],
  enum_types=[
    _CHANGE_STATE,
  ],
  options=None,
  is_extendable=False,
  syntax='proto3',
  extension_ranges=[],
  oneofs=[
  ],
  serialized_start=248,
  serialized_end=478,
)

_CHANGEBATCH.fields_by_name['changes'].message_type = _CHANGE
_CHANGE.fields_by_name['state'].enum_type = _CHANGE_STATE
_CHANGE.fields_by_name['data'].message_type = google_dot_protobuf_dot_any__pb2._ANY
_CHANGE_STATE.containing_type = _CHANGE
DESCRIPTOR.message_types_by_name['Request'] = _REQUEST
DESCRIPTOR.message_types_by_name['ChangeBatch'] = _CHANGEBATCH
DESCRIPTOR.message_types_by_name['Change'] = _CHANGE
_sym_db.RegisterFileDescriptor(DESCRIPTOR)

Request = _reflection.GeneratedProtocolMessageType('Request', (_message.Message,), dict(
  DESCRIPTOR = _REQUEST,
  __module__ = 'google.watcher.v1.watch_pb2'
  # @@protoc_insertion_point(class_scope:google.watcher.v1.Request)
  ))
_sym_db.RegisterMessage(Request)

ChangeBatch = _reflection.GeneratedProtocolMessageType('ChangeBatch', (_message.Message,), dict(
  DESCRIPTOR = _CHANGEBATCH,
  __module__ = 'google.watcher.v1.watch_pb2'
  # @@protoc_insertion_point(class_scope:google.watcher.v1.ChangeBatch)
  ))
_sym_db.RegisterMessage(ChangeBatch)

Change = _reflection.GeneratedProtocolMessageType('Change', (_message.Message,), dict(
  DESCRIPTOR = _CHANGE,
  __module__ = 'google.watcher.v1.watch_pb2'
  # @@protoc_insertion_point(class_scope:google.watcher.v1.Change)
  ))
_sym_db.RegisterMessage(Change)


DESCRIPTOR.has_options = True
DESCRIPTOR._options = _descriptor._ParseOptions(descriptor_pb2.FileOptions(), _b('\n\025com.google.watcher.v1B\nWatchProtoP\001Z8google.golang.org/genproto/googleapis/watcher/v1;watcher'))
try:
  # THESE ELEMENTS WILL BE DEPRECATED.
  # Please use the generated *_pb2_grpc.py files instead.
  import grpc
  from grpc.beta import implementations as beta_implementations
  from grpc.beta import interfaces as beta_interfaces
  from grpc.framework.common import cardinality
  from grpc.framework.interfaces.face import utilities as face_utilities


  class WatcherStub(object):
    """## API Overview

    [Watcher][] lets a client watch for updates to a named entity, such as a
    directory or database table. For each watched entity, the client receives a
    reliable stream of watch events, without re-ordering.

    Watching is done by sending an RPC to a service that implements the API. The
    argument to the RPC contains the name of the entity. The result stream
    consists of a sequence of Change messages that the service continues to
    send until the call fails or is cancelled.

    ## Data model

    This API assumes that each *entity* has a name and a
    set of *elements*, where each element has a name and a value. The
    entity's name must be a unique identifier within the service, such as
    a resource name. What constitutes an entity or element is
    implementation-specific: for example, a file system implementation
    might define an entity as either a directory or a file, and elements would be
    child files or directories of that entity.

    The Watch API allows a client to watch an entity E's immediate
    elements or the whole tree rooted at E. Elements are organized into
    a hierarchy ("" at the top; the rest follows the natural hierarchy of the
    namespace of elements that is being watched). For example, when
    recursively watching a filesystem namespace, X is an ancestor of
    X/Y and X/Y/Z).

    ## Watch request

    When a client makes a request to watch an entity, it can indicate
    whether it wants to receive the initial state of the entity, just
    new changes to the entity, or resume watching from a particular
    point in a previous watch stream, specified with a `resume_marker` value.
    It can also indicate whether it wants to watch only one entity or all
    entities in the subtree rooted at a particular entity's name.

    On receiving a watch request for an entity, the server sends one or more
    messages to the client. The first message informs the client that the server
    has registered the client's request: the instant of time when the
    client receives the event is referred to as the client's "watch
    point" for that entity.

    ## Atomic delivery

    The response stream consists of a sequence of Change messages. Each
    message contains an `continued` bit. A sub-sequence of Change messages with
    `continued=true` followed by a Change message with `continued=false` forms an
    *atomic group*. Systems that support multi-element atomic updates may
    guarantee that all changes resulting from a single atomic
    update are delivered in the same atomic group. It is up to the
    documentation of a particular system that implements the Watch API to
    document whether or not it supports such grouping. We expect that most
    callers will ignore the notion of atomic delivery and the `continued` bit,
    i.e., they will just process each Change message as it is received.

    ## Batching

    Multiple Change messages may be grouped into a single ChangeBatch message
    to reduce message transfer overhead. A single ChangeBatch may contain many
    atomic groups, or a single atomic group may be split across many
    ChangeBatch messages.

    ## Initial State

    The first atomic group delivered by a watch call is special. It is
    delivered as soon as possible and contains the initial state of the
    entity being watched. The client should consider itself caught up
    after processing this first atomic group.

    The messages in the first atomic group will either refer to the
    entity itself (`Change.element` == "") or to elements inside the
    entity (`Change.element` != ""). Here are the cases to consider:

    1. `resume_marker` is "" or not specified: For every element P
    (including the entity itself) that exists, there will be at least
    one message delivered with element == P and the last such message
    will contain the current state of P. For every element Q
    (including the entity itself) that does not exist, either no
    message will be delivered, or the last message for Q will have
    state == DOES_NOT_EXIST. At least one message for element="" will
    be delivered.

    2. `resume_marker` == "now": there will be exactly one message with
    element = "" and state INITIAL_STATE_SKIPPED. The client cannot
    assume whether or not the entity exists after receiving this
    message.

    3. `resume_marker` has a value R from a preceding watch call on this
    entity: The same messages as described in (1) will be delivered to
    the client, except that any information implied by messages received
    on the preceding call up to and including R may not be
    delivered. The expectation is that the client will start with state
    it had built up from the preceding watch call, apply the changes
    received from this call, and build an up-to-date view of the entity
    without having to fetch a potentially large amount of information
    that has not changed. Note that some information that had already
    been delivered by the preceding call might be delivered again.

    ## Ordering and Reliability

    The Change messages that apply to a particular element of the entity are
    delivered eventually in order without loss for the duration of the RPC. Note
    however that if multiple Changes apply to the same element, the
    implementation is free to suppress them and deliver just the last one. The
    underlying system must provide the guarantee that any relevant update
    received for an entity E after a client's watch point for E MUST be delivered
    to that client.

    These tight guarantees allow for the following simplifications in the client:

    1. The client does not need to have a separate polling loop to make up for
    missed updates.

    2. The client does not need to manage timestamps/versions manually; the
    last update delivered corresponds to the eventual state of the entity.

    Example: a calendar entry may have elements named { "starttime", "endtime",
    "attendees" } with corresponding values or it may have a single element name
    "entry" with a serialized proto for the calendar entry.

    ## Ordering constraints for parents/descendants

    The Watch API provides guarantees regarding the order in which
    messages for a parent and its descendants are delivered:

    1. The creation of an ancestor (i.e., the first EXISTS message for
    the ancestor) is reported before the creation of any of its
    descendants.

    2. The deletion of an ancestor (via a DOES_NOT_EXIST message)
    implies the deletion of all its descendants. The service will
    not deliver any messages for the descendants until the parent
    has been recreated.

    The service that a client uses to connect to the watcher system.
    The errors returned by the service are in the canonical error space,
    see [google.rpc.Code][].
    """

    def __init__(self, channel):
      """Constructor.

      Args:
        channel: A grpc.Channel.
      """
      self.Watch = channel.unary_stream(
          '/google.watcher.v1.Watcher/Watch',
          request_serializer=Request.SerializeToString,
          response_deserializer=ChangeBatch.FromString,
          )


  class WatcherServicer(object):
    """## API Overview

    [Watcher][] lets a client watch for updates to a named entity, such as a
    directory or database table. For each watched entity, the client receives a
    reliable stream of watch events, without re-ordering.

    Watching is done by sending an RPC to a service that implements the API. The
    argument to the RPC contains the name of the entity. The result stream
    consists of a sequence of Change messages that the service continues to
    send until the call fails or is cancelled.

    ## Data model

    This API assumes that each *entity* has a name and a
    set of *elements*, where each element has a name and a value. The
    entity's name must be a unique identifier within the service, such as
    a resource name. What constitutes an entity or element is
    implementation-specific: for example, a file system implementation
    might define an entity as either a directory or a file, and elements would be
    child files or directories of that entity.

    The Watch API allows a client to watch an entity E's immediate
    elements or the whole tree rooted at E. Elements are organized into
    a hierarchy ("" at the top; the rest follows the natural hierarchy of the
    namespace of elements that is being watched). For example, when
    recursively watching a filesystem namespace, X is an ancestor of
    X/Y and X/Y/Z).

    ## Watch request

    When a client makes a request to watch an entity, it can indicate
    whether it wants to receive the initial state of the entity, just
    new changes to the entity, or resume watching from a particular
    point in a previous watch stream, specified with a `resume_marker` value.
    It can also indicate whether it wants to watch only one entity or all
    entities in the subtree rooted at a particular entity's name.

    On receiving a watch request for an entity, the server sends one or more
    messages to the client. The first message informs the client that the server
    has registered the client's request: the instant of time when the
    client receives the event is referred to as the client's "watch
    point" for that entity.

    ## Atomic delivery

    The response stream consists of a sequence of Change messages. Each
    message contains an `continued` bit. A sub-sequence of Change messages with
    `continued=true` followed by a Change message with `continued=false` forms an
    *atomic group*. Systems that support multi-element atomic updates may
    guarantee that all changes resulting from a single atomic
    update are delivered in the same atomic group. It is up to the
    documentation of a particular system that implements the Watch API to
    document whether or not it supports such grouping. We expect that most
    callers will ignore the notion of atomic delivery and the `continued` bit,
    i.e., they will just process each Change message as it is received.

    ## Batching

    Multiple Change messages may be grouped into a single ChangeBatch message
    to reduce message transfer overhead. A single ChangeBatch may contain many
    atomic groups, or a single atomic group may be split across many
    ChangeBatch messages.

    ## Initial State

    The first atomic group delivered by a watch call is special. It is
    delivered as soon as possible and contains the initial state of the
    entity being watched. The client should consider itself caught up
    after processing this first atomic group.

    The messages in the first atomic group will either refer to the
    entity itself (`Change.element` == "") or to elements inside the
    entity (`Change.element` != ""). Here are the cases to consider:

    1. `resume_marker` is "" or not specified: For every element P
    (including the entity itself) that exists, there will be at least
    one message delivered with element == P and the last such message
    will contain the current state of P. For every element Q
    (including the entity itself) that does not exist, either no
    message will be delivered, or the last message for Q will have
    state == DOES_NOT_EXIST. At least one message for element="" will
    be delivered.

    2. `resume_marker` == "now": there will be exactly one message with
    element = "" and state INITIAL_STATE_SKIPPED. The client cannot
    assume whether or not the entity exists after receiving this
    message.

    3. `resume_marker` has a value R from a preceding watch call on this
    entity: The same messages as described in (1) will be delivered to
    the client, except that any information implied by messages received
    on the preceding call up to and including R may not be
    delivered. The expectation is that the client will start with state
    it had built up from the preceding watch call, apply the changes
    received from this call, and build an up-to-date view of the entity
    without having to fetch a potentially large amount of information
    that has not changed. Note that some information that had already
    been delivered by the preceding call might be delivered again.

    ## Ordering and Reliability

    The Change messages that apply to a particular element of the entity are
    delivered eventually in order without loss for the duration of the RPC. Note
    however that if multiple Changes apply to the same element, the
    implementation is free to suppress them and deliver just the last one. The
    underlying system must provide the guarantee that any relevant update
    received for an entity E after a client's watch point for E MUST be delivered
    to that client.

    These tight guarantees allow for the following simplifications in the client:

    1. The client does not need to have a separate polling loop to make up for
    missed updates.

    2. The client does not need to manage timestamps/versions manually; the
    last update delivered corresponds to the eventual state of the entity.

    Example: a calendar entry may have elements named { "starttime", "endtime",
    "attendees" } with corresponding values or it may have a single element name
    "entry" with a serialized proto for the calendar entry.

    ## Ordering constraints for parents/descendants

    The Watch API provides guarantees regarding the order in which
    messages for a parent and its descendants are delivered:

    1. The creation of an ancestor (i.e., the first EXISTS message for
    the ancestor) is reported before the creation of any of its
    descendants.

    2. The deletion of an ancestor (via a DOES_NOT_EXIST message)
    implies the deletion of all its descendants. The service will
    not deliver any messages for the descendants until the parent
    has been recreated.

    The service that a client uses to connect to the watcher system.
    The errors returned by the service are in the canonical error space,
    see [google.rpc.Code][].
    """

    def Watch(self, request, context):
      """Start a streaming RPC to get watch information from the server.
      """
      context.set_code(grpc.StatusCode.UNIMPLEMENTED)
      context.set_details('Method not implemented!')
      raise NotImplementedError('Method not implemented!')


  def add_WatcherServicer_to_server(servicer, server):
    rpc_method_handlers = {
        'Watch': grpc.unary_stream_rpc_method_handler(
            servicer.Watch,
            request_deserializer=Request.FromString,
            response_serializer=ChangeBatch.SerializeToString,
        ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
        'google.watcher.v1.Watcher', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


  class BetaWatcherServicer(object):
    """The Beta API is deprecated for 0.15.0 and later.

    It is recommended to use the GA API (classes and functions in this
    file not marked beta) for all further purposes. This class was generated
    only to ease transition from grpcio<0.15.0 to grpcio>=0.15.0."""
    """## API Overview

    [Watcher][] lets a client watch for updates to a named entity, such as a
    directory or database table. For each watched entity, the client receives a
    reliable stream of watch events, without re-ordering.

    Watching is done by sending an RPC to a service that implements the API. The
    argument to the RPC contains the name of the entity. The result stream
    consists of a sequence of Change messages that the service continues to
    send until the call fails or is cancelled.

    ## Data model

    This API assumes that each *entity* has a name and a
    set of *elements*, where each element has a name and a value. The
    entity's name must be a unique identifier within the service, such as
    a resource name. What constitutes an entity or element is
    implementation-specific: for example, a file system implementation
    might define an entity as either a directory or a file, and elements would be
    child files or directories of that entity.

    The Watch API allows a client to watch an entity E's immediate
    elements or the whole tree rooted at E. Elements are organized into
    a hierarchy ("" at the top; the rest follows the natural hierarchy of the
    namespace of elements that is being watched). For example, when
    recursively watching a filesystem namespace, X is an ancestor of
    X/Y and X/Y/Z).

    ## Watch request

    When a client makes a request to watch an entity, it can indicate
    whether it wants to receive the initial state of the entity, just
    new changes to the entity, or resume watching from a particular
    point in a previous watch stream, specified with a `resume_marker` value.
    It can also indicate whether it wants to watch only one entity or all
    entities in the subtree rooted at a particular entity's name.

    On receiving a watch request for an entity, the server sends one or more
    messages to the client. The first message informs the client that the server
    has registered the client's request: the instant of time when the
    client receives the event is referred to as the client's "watch
    point" for that entity.

    ## Atomic delivery

    The response stream consists of a sequence of Change messages. Each
    message contains an `continued` bit. A sub-sequence of Change messages with
    `continued=true` followed by a Change message with `continued=false` forms an
    *atomic group*. Systems that support multi-element atomic updates may
    guarantee that all changes resulting from a single atomic
    update are delivered in the same atomic group. It is up to the
    documentation of a particular system that implements the Watch API to
    document whether or not it supports such grouping. We expect that most
    callers will ignore the notion of atomic delivery and the `continued` bit,
    i.e., they will just process each Change message as it is received.

    ## Batching

    Multiple Change messages may be grouped into a single ChangeBatch message
    to reduce message transfer overhead. A single ChangeBatch may contain many
    atomic groups, or a single atomic group may be split across many
    ChangeBatch messages.

    ## Initial State

    The first atomic group delivered by a watch call is special. It is
    delivered as soon as possible and contains the initial state of the
    entity being watched. The client should consider itself caught up
    after processing this first atomic group.

    The messages in the first atomic group will either refer to the
    entity itself (`Change.element` == "") or to elements inside the
    entity (`Change.element` != ""). Here are the cases to consider:

    1. `resume_marker` is "" or not specified: For every element P
    (including the entity itself) that exists, there will be at least
    one message delivered with element == P and the last such message
    will contain the current state of P. For every element Q
    (including the entity itself) that does not exist, either no
    message will be delivered, or the last message for Q will have
    state == DOES_NOT_EXIST. At least one message for element="" will
    be delivered.

    2. `resume_marker` == "now": there will be exactly one message with
    element = "" and state INITIAL_STATE_SKIPPED. The client cannot
    assume whether or not the entity exists after receiving this
    message.

    3. `resume_marker` has a value R from a preceding watch call on this
    entity: The same messages as described in (1) will be delivered to
    the client, except that any information implied by messages received
    on the preceding call up to and including R may not be
    delivered. The expectation is that the client will start with state
    it had built up from the preceding watch call, apply the changes
    received from this call, and build an up-to-date view of the entity
    without having to fetch a potentially large amount of information
    that has not changed. Note that some information that had already
    been delivered by the preceding call might be delivered again.

    ## Ordering and Reliability

    The Change messages that apply to a particular element of the entity are
    delivered eventually in order without loss for the duration of the RPC. Note
    however that if multiple Changes apply to the same element, the
    implementation is free to suppress them and deliver just the last one. The
    underlying system must provide the guarantee that any relevant update
    received for an entity E after a client's watch point for E MUST be delivered
    to that client.

    These tight guarantees allow for the following simplifications in the client:

    1. The client does not need to have a separate polling loop to make up for
    missed updates.

    2. The client does not need to manage timestamps/versions manually; the
    last update delivered corresponds to the eventual state of the entity.

    Example: a calendar entry may have elements named { "starttime", "endtime",
    "attendees" } with corresponding values or it may have a single element name
    "entry" with a serialized proto for the calendar entry.

    ## Ordering constraints for parents/descendants

    The Watch API provides guarantees regarding the order in which
    messages for a parent and its descendants are delivered:

    1. The creation of an ancestor (i.e., the first EXISTS message for
    the ancestor) is reported before the creation of any of its
    descendants.

    2. The deletion of an ancestor (via a DOES_NOT_EXIST message)
    implies the deletion of all its descendants. The service will
    not deliver any messages for the descendants until the parent
    has been recreated.

    The service that a client uses to connect to the watcher system.
    The errors returned by the service are in the canonical error space,
    see [google.rpc.Code][].
    """
    def Watch(self, request, context):
      """Start a streaming RPC to get watch information from the server.
      """
      context.code(beta_interfaces.StatusCode.UNIMPLEMENTED)


  class BetaWatcherStub(object):
    """The Beta API is deprecated for 0.15.0 and later.

    It is recommended to use the GA API (classes and functions in this
    file not marked beta) for all further purposes. This class was generated
    only to ease transition from grpcio<0.15.0 to grpcio>=0.15.0."""
    """## API Overview

    [Watcher][] lets a client watch for updates to a named entity, such as a
    directory or database table. For each watched entity, the client receives a
    reliable stream of watch events, without re-ordering.

    Watching is done by sending an RPC to a service that implements the API. The
    argument to the RPC contains the name of the entity. The result stream
    consists of a sequence of Change messages that the service continues to
    send until the call fails or is cancelled.

    ## Data model

    This API assumes that each *entity* has a name and a
    set of *elements*, where each element has a name and a value. The
    entity's name must be a unique identifier within the service, such as
    a resource name. What constitutes an entity or element is
    implementation-specific: for example, a file system implementation
    might define an entity as either a directory or a file, and elements would be
    child files or directories of that entity.

    The Watch API allows a client to watch an entity E's immediate
    elements or the whole tree rooted at E. Elements are organized into
    a hierarchy ("" at the top; the rest follows the natural hierarchy of the
    namespace of elements that is being watched). For example, when
    recursively watching a filesystem namespace, X is an ancestor of
    X/Y and X/Y/Z).

    ## Watch request

    When a client makes a request to watch an entity, it can indicate
    whether it wants to receive the initial state of the entity, just
    new changes to the entity, or resume watching from a particular
    point in a previous watch stream, specified with a `resume_marker` value.
    It can also indicate whether it wants to watch only one entity or all
    entities in the subtree rooted at a particular entity's name.

    On receiving a watch request for an entity, the server sends one or more
    messages to the client. The first message informs the client that the server
    has registered the client's request: the instant of time when the
    client receives the event is referred to as the client's "watch
    point" for that entity.

    ## Atomic delivery

    The response stream consists of a sequence of Change messages. Each
    message contains an `continued` bit. A sub-sequence of Change messages with
    `continued=true` followed by a Change message with `continued=false` forms an
    *atomic group*. Systems that support multi-element atomic updates may
    guarantee that all changes resulting from a single atomic
    update are delivered in the same atomic group. It is up to the
    documentation of a particular system that implements the Watch API to
    document whether or not it supports such grouping. We expect that most
    callers will ignore the notion of atomic delivery and the `continued` bit,
    i.e., they will just process each Change message as it is received.

    ## Batching

    Multiple Change messages may be grouped into a single ChangeBatch message
    to reduce message transfer overhead. A single ChangeBatch may contain many
    atomic groups, or a single atomic group may be split across many
    ChangeBatch messages.

    ## Initial State

    The first atomic group delivered by a watch call is special. It is
    delivered as soon as possible and contains the initial state of the
    entity being watched. The client should consider itself caught up
    after processing this first atomic group.

    The messages in the first atomic group will either refer to the
    entity itself (`Change.element` == "") or to elements inside the
    entity (`Change.element` != ""). Here are the cases to consider:

    1. `resume_marker` is "" or not specified: For every element P
    (including the entity itself) that exists, there will be at least
    one message delivered with element == P and the last such message
    will contain the current state of P. For every element Q
    (including the entity itself) that does not exist, either no
    message will be delivered, or the last message for Q will have
    state == DOES_NOT_EXIST. At least one message for element="" will
    be delivered.

    2. `resume_marker` == "now": there will be exactly one message with
    element = "" and state INITIAL_STATE_SKIPPED. The client cannot
    assume whether or not the entity exists after receiving this
    message.

    3. `resume_marker` has a value R from a preceding watch call on this
    entity: The same messages as described in (1) will be delivered to
    the client, except that any information implied by messages received
    on the preceding call up to and including R may not be
    delivered. The expectation is that the client will start with state
    it had built up from the preceding watch call, apply the changes
    received from this call, and build an up-to-date view of the entity
    without having to fetch a potentially large amount of information
    that has not changed. Note that some information that had already
    been delivered by the preceding call might be delivered again.

    ## Ordering and Reliability

    The Change messages that apply to a particular element of the entity are
    delivered eventually in order without loss for the duration of the RPC. Note
    however that if multiple Changes apply to the same element, the
    implementation is free to suppress them and deliver just the last one. The
    underlying system must provide the guarantee that any relevant update
    received for an entity E after a client's watch point for E MUST be delivered
    to that client.

    These tight guarantees allow for the following simplifications in the client:

    1. The client does not need to have a separate polling loop to make up for
    missed updates.

    2. The client does not need to manage timestamps/versions manually; the
    last update delivered corresponds to the eventual state of the entity.

    Example: a calendar entry may have elements named { "starttime", "endtime",
    "attendees" } with corresponding values or it may have a single element name
    "entry" with a serialized proto for the calendar entry.

    ## Ordering constraints for parents/descendants

    The Watch API provides guarantees regarding the order in which
    messages for a parent and its descendants are delivered:

    1. The creation of an ancestor (i.e., the first EXISTS message for
    the ancestor) is reported before the creation of any of its
    descendants.

    2. The deletion of an ancestor (via a DOES_NOT_EXIST message)
    implies the deletion of all its descendants. The service will
    not deliver any messages for the descendants until the parent
    has been recreated.

    The service that a client uses to connect to the watcher system.
    The errors returned by the service are in the canonical error space,
    see [google.rpc.Code][].
    """
    def Watch(self, request, timeout, metadata=None, with_call=False, protocol_options=None):
      """Start a streaming RPC to get watch information from the server.
      """
      raise NotImplementedError()


  def beta_create_Watcher_server(servicer, pool=None, pool_size=None, default_timeout=None, maximum_timeout=None):
    """The Beta API is deprecated for 0.15.0 and later.

    It is recommended to use the GA API (classes and functions in this
    file not marked beta) for all further purposes. This function was
    generated only to ease transition from grpcio<0.15.0 to grpcio>=0.15.0"""
    request_deserializers = {
      ('google.watcher.v1.Watcher', 'Watch'): Request.FromString,
    }
    response_serializers = {
      ('google.watcher.v1.Watcher', 'Watch'): ChangeBatch.SerializeToString,
    }
    method_implementations = {
      ('google.watcher.v1.Watcher', 'Watch'): face_utilities.unary_stream_inline(servicer.Watch),
    }
    server_options = beta_implementations.server_options(request_deserializers=request_deserializers, response_serializers=response_serializers, thread_pool=pool, thread_pool_size=pool_size, default_timeout=default_timeout, maximum_timeout=maximum_timeout)
    return beta_implementations.server(method_implementations, options=server_options)


  def beta_create_Watcher_stub(channel, host=None, metadata_transformer=None, pool=None, pool_size=None):
    """The Beta API is deprecated for 0.15.0 and later.

    It is recommended to use the GA API (classes and functions in this
    file not marked beta) for all further purposes. This function was
    generated only to ease transition from grpcio<0.15.0 to grpcio>=0.15.0"""
    request_serializers = {
      ('google.watcher.v1.Watcher', 'Watch'): Request.SerializeToString,
    }
    response_deserializers = {
      ('google.watcher.v1.Watcher', 'Watch'): ChangeBatch.FromString,
    }
    cardinalities = {
      'Watch': cardinality.Cardinality.UNARY_STREAM,
    }
    stub_options = beta_implementations.stub_options(host=host, metadata_transformer=metadata_transformer, request_serializers=request_serializers, response_deserializers=response_deserializers, thread_pool=pool, thread_pool_size=pool_size)
    return beta_implementations.dynamic_stub(channel, 'google.watcher.v1.Watcher', cardinalities, options=stub_options)
except ImportError:
  pass
# @@protoc_insertion_point(module_scope)
